Here’s a structured summary of the **LU factorization process** as described in your notes, distinguishing **no pivoting**, **partial pivoting**, and **full (complete) pivoting**:

---

### **1. LU Factorization Without Pivoting**

**Core idea:**
LU factorization decomposes a nonsingular square matrix ( A ) as
[
A = LU,
]
where

* ( L ) is **unit lower triangular** (1’s on the diagonal, multipliers below), and
* ( U ) is **upper triangular**.

**Process:**

1. Apply **Gaussian elimination** to eliminate elements below the diagonal column by column.
2. Each elimination step corresponds to a **Gauss transformation** ( M_i^{-1} = I - \ell_i e_i^T ), where ( \ell_i ) contains the multipliers used to zero out elements below the pivot ( a_{ii} ).
3. After all steps:
   [
   U = M_{n-1}^{-1} \cdots M_1^{-1} A, \quad \text{and hence} \quad A = M_1 M_2 \cdots M_{n-1} U = LU.
   ]
4. ( L ) is the product of the ( M_i ) matrices, each of which is lower triangular.

**Key properties:**

* Computational cost ≈ ( \tfrac{2}{3}n^3 ) flops.
* Works **only if no zero pivots** occur — i.e., all ( a_{ii} \neq 0 ).
* May be **numerically unstable** even for nonsingular ( A ).

---

### **2. LU Factorization with Partial Pivoting**

**Motivation:**
Without pivoting, a small pivot element can cause large roundoff errors or division by zero.
**Solution:** swap rows to bring a better (larger-magnitude) pivot into the diagonal position.

**Process:**

1. At each step ( i ), find the largest-magnitude element in the **first column of the active submatrix**.
2. Use a **row permutation matrix** ( P_i ) to bring this element to position ( (i, i) ).
3. Apply the Gauss transformation ( M_i^{-1} ) to eliminate entries below the pivot.
4. Continue recursively.

At the end:
[
U = M_{n-1}^{-1} P_{n-1} \cdots M_1^{-1} P_1 A,
]
which implies:
[
PA = LU,
]
where ( P = P_{n-1} \cdots P_1 ) is the cumulative permutation matrix.

**Solving system:**
[
Ax = b \Rightarrow PAx = Pb \Rightarrow LUx = Pb,
]
then solve:

1. ( Ly = Pb ) (forward substitution)
2. ( Ux = y ) (back substitution)

**Key properties:**

* Much more stable than no pivoting.
* Requires **row swaps only** (cheap to implement).
* Computational cost remains ( \tfrac{2}{3}n^3 ) flops.
* Usually sufficient in practice.

---

### **3. LU Factorization with Full (Complete) Pivoting**

**Motivation:**
Partial pivoting can still fail for some pathological matrices.
**Solution:** Search for the best pivot in the **entire active submatrix**, not just the first column.

**Process:**

1. In the current active matrix (bottom-right ( (n - i + 1) \times (n - i + 1) ) block), find the **element of largest magnitude**.
2. Swap both **rows and columns** to bring it to position ( (i, i) ):

   * ( P_i ) = row permutation,
   * ( Q_i ) = column permutation.
3. Perform elimination as in standard Gaussian elimination.

Final result:
[
P A Q = L U,
]
where ( P ) and ( Q ) are the accumulated row and column permutations.

**Key properties:**

* **Unconditionally stable** (minimizes growth of roundoff error).
* More computationally expensive (extra scanning and column swaps).
* Column swaps complicate back-substitution (since ( Q ) changes variable ordering).

---

### **Comparison Summary**

| Feature                     | No Pivoting                 | Partial Pivoting  | Full Pivoting                   |
| --------------------------- | --------------------------- | ----------------- | ------------------------------- |
| **Row swaps**               | No                          | Yes               | Yes                             |
| **Column swaps**            | No                          | No                | Yes                             |
| **Pivot selection**         | Diagonal element ( a_{ii} ) | Largest in column | Largest in active submatrix     |
| **Stability**               | Poor                        | Good (usually)    | Excellent                       |
| **Extra cost**              | None                        | Small (O(n²))     | Higher (extra searches + swaps) |
| **Resulting factorization** | ( A = LU )                  | ( P A = L U )     | ( P A Q = L U )                 |

---

Would you like a short visual diagram (arrows showing how ( A ) transforms to ( L ), ( U ), and ( P ), ( Q )) to accompany this summary?
